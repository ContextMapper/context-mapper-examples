/**
 * Automatically derived with the OOAD step 3 transformation:
 * (adjusted data types in services manually)
 * 
 * After having derived this BC, we generated the claims-use-case-entities.jdl file using our generic generator:
 * https://contextmapper.org/docs/generic-freemarker-generator/
 */
BoundedContext ClaimsManagement implements ClaimsManagement {
	domainVisionStatement "This Bounded Context realizes the following subdomains: ClaimsManagement"
	type FEATURE
	/* This Aggregate contains the entities and services of the 'ClaimsManagement' subdomain.
	 * TODO: You can now refactor the Aggregate, for example by using the 'Split Aggregate by Entities' architectural refactoring.
	 * TODO: Add attributes and operations to the entities.
	 * TODO: Add operations to the services.
	 * Find examples and further instructions on our website: https://contextmapper.org/docs/rapid-ooad/ */
	Aggregate ClaimsManagementAggregate {
		Service AccidentService {
			void submitClaim (@Claim claim);
			PolicyExistanceVerification verifyExistanceOfPolicy (@Claim claim);
			void assignAgent (@Claim claim, @Agent agent);
			PolicyVerification verifyPolicy (@Claim claim);
			void payClaimant (@Claim claim);
			void closeClaim (@Claim claim);
		}
		Entity Claim {
			Date date
			Double amountClaimed
			String ^description
			ClaimID claimId
			- Agent agent
		}
		Entity Policy {
			Date startDate
			Date endDate
			PolicyID policyId
			- List<Claim> claims
		}
		Entity Contract {
			ContractID contractId
			- List<Policy> policies
		}
		Entity Agent {
			Long personalID
			String firstName
			String lastName
			AgentID agentId
		}
		Entity Claimant {
			String firstName
			String lastName
			ClaimantID claimantId
			- List<Claim> claims
		}
	}
}

/**
 * Automatically derived with the OOAD step 2 transformation:
 * (manually concretized some datatypes) 
 */
Domain Insurance_Application {
	Subdomain ClaimsManagement {
		domainVisionStatement "Aims at promoting the following benefit for a Claimant: A claimant submits a claim and and gets paid from the insurance company."
		Entity Claim {
			Date date
			Double amountClaimed
			String ^description
			- Agent agent
		}
		Entity Policy {
			Date startDate
			Date endDate
			- List<Claim> claims
		}
		Entity Contract {
			- List<Policy> policies
		}
		Entity Agent {
			Long personalID
			String firstName
			String lastName
		}
		Entity Claimant {
			String firstName
			String lastName
			- List<Claim> claims
		}
		Service AccidentService {
			submitClaim;
			verifyExistanceOfPolicy;
			assignAgent;
			verifyPolicy;
			payClaimant;
			closeClaim;
		}
	}

}

/**
 * The following Use Case "Get paid for car accident" has been taken out of Alistair Cockburn's book on "Writing Effective Use Cases".
 * Step 1: This is the part of this CML file which has been modeled manually: (all the parts above are generated by our OOAD transformations)
 */
UseCase Get_paid_for_car_accident { // title
	actor "Claimant" // primary actor
	interactions
    	"submit" a "Claim" with its "date", "amountClaimed", "description" for a "Policy", // step 1: claimant submits claim
    	"verifyExistanceOf" "Policy" with its "startDate", "endDate" for a "Contract",     // step 2: insurance company verifies that valid policy exists
    	"assign" an "Agent" with its "personalID", "firstName", "lastName" for "Claim",    // step 3: agent is assigned to claim
    	"verify" "Policy" for a "Contract",                                                // step 4: agent verifies all details are within policy guidelines
    	"pay" "Claimant" with its "firstName", "lastName",                                 // step 5 (1): claimant gets paid
    	"close" "Claim" for "Claimant"                                                     // step 5 (2): file/claim gets closed
	benefit "A claimant submits a claim and and gets paid from the insurance company." // story (brief summary)
	scope "Insurance company" // scope
	level "Summary" // level
}
